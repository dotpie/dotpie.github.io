[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "archive",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Categories\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Reading Time (Low to High)\n        \n         \n          Reading Time (High to Low)\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nFactorial in Python\n\n\nImplementing Factorial in Python with three different methods\n\n\n5 min\n\n\n\nalgorithms\n\n\n\n\ndotpie\n\n\nOct 2, 2024\n\n\n\n\n\n\n\n\n\n\n\nBeing Part of Other’s Growth\n\n\n4 min\n\n\n\nsoft-skills\n\n\nself-review\n\n\n\n\ndotpie\n\n\nSep 29, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "being-part-of-others-growth.html",
    "href": "being-part-of-others-growth.html",
    "title": "Being Part of Other’s Growth",
    "section": "",
    "text": "This is a personal reflection on how I can contribute to other’s growth. It is based on my personal experiences so that it could be biased."
  },
  {
    "objectID": "being-part-of-others-growth.html#a-knowledge-sharing-chain",
    "href": "being-part-of-others-growth.html#a-knowledge-sharing-chain",
    "title": "Being Part of Other’s Growth",
    "section": "A knowledge-sharing-chain",
    "text": "A knowledge-sharing-chain\nWhat is the best way to pass on knowledge and experience to others? As a tutor, mentor, or a colleague, it was a question that I often asked myself. Most of time, I was in a position to help others grow, especially in coding and development. At the time, what I could do was to share my experiences and difficulties with others, because I was also on the middle of learning step.\nSharing was enough when I was in student circle. In circle, we were all learned together, same time, same topic. The difficulties I encountered was highly repeated to others. What I tried was stacking my own difficulties and solutions, then share it when other faced the similar issue. This kind of ‘sharing chain’ was fully effective to boost our learning speed. We were a student and a teacher at the same time. Through this process, I learned to pick up the problems that other could face, and how to share the solution in a way that they could understand."
  },
  {
    "objectID": "being-part-of-others-growth.html#the-requirements-for-sharing-knowledge",
    "href": "being-part-of-others-growth.html#the-requirements-for-sharing-knowledge",
    "title": "Being Part of Other’s Growth",
    "section": "The requirements for sharing knowledge",
    "text": "The requirements for sharing knowledge\nTo make other understand the solution, tutor have to is understanding the fundamental background of the whole situation. Tutor have to decide where to focus on, then connect the key points to make a clear path.\nYet, I was a kind of person who explore the whole picture of the problem, point out the key points is kind of complicated task. There were too many things to explain and every detail looked important. To overcome this, I made a strategy by breaking down the problem into small pieces, then pick up the key points of small pieces. After done this, I could make a clear path to the solution.\nSurely there might be someone who would like to know whole picture of the problem, but most of time, too much information makes them confused. Therefore, to give a proper answer, understanding listener’s background is essential. This is not a technical stuff, but a soft skill.\nThrough my experiences, I listed the principle to share the knowledge effectively.\n\nUnderstand the listener’s background: To decide the depth of the explanation, checking the background is essential. The language of explanation should be familiar to the listener.\nFind out how much motivated the listener is: The motivation of the lister means how much they want to know the solution. Tutoring and Teaching should not be done in a one-off session, since every knowledge has its own depth. If the listenr wants to know only the solution, then just give the solution. Learning shouldn’t be a burden. Theory and background can be explained later.\nAssociate the problem with the listener’s goal: People tends to focus when the problem is related to their own’s. As mentioned above, the listener’s motivation is important. If the listener has a goal, then associate the problem with the goal. This will make the listener feels that the issue familiar to them. Make them feel that they are not learning, but solving their own problem.\n\nThese are aimed to make the learner acquire the way to solve the problem. The goal of tutoring is not to give the solution, but to make the listener understand the way to solve the problem."
  },
  {
    "objectID": "being-part-of-others-growth.html#proactive-contribution",
    "href": "being-part-of-others-growth.html#proactive-contribution",
    "title": "Being Part of Other’s Growth",
    "section": "Proactive contribution",
    "text": "Proactive contribution\nThe most important thing in sharing knowledge is to be proactive. During the tutoring process, the tutee are going to learn how to find problems and how to ask properly, such as what to ask, what looked important, and what could be suspicious. After the steps, the tutee will be able to discuss the problem with others, and find the solution by themselves. A kind of knowledge-sharing-chain will be formed.\nTutor should not be a person who gives the solution, but the person who thinks together with the tutee. To do this, tutor have to be proactive, which means tutor have their own motivation to learn and think. This is the most important thing to be a being part of other’s growth."
  },
  {
    "objectID": "being-part-of-others-growth.html#conclusion",
    "href": "being-part-of-others-growth.html#conclusion",
    "title": "Being Part of Other’s Growth",
    "section": "Conclusion",
    "text": "Conclusion\nI am still learning how to learn as tutee and tutor. It will be continued during my developer life, and I hope that I could be a developer who have solid foundation of knowledge and experience."
  },
  {
    "objectID": "algorithm/factorial.html",
    "href": "algorithm/factorial.html",
    "title": "Factorial in Python",
    "section": "",
    "text": "Factorial is the product of all positive integers less than or equal to.. For example, factorial of 5 is calculated by the equation below:\n\\[5! = 5 * 4 * 3 * 2 * 1 = 120\\]\nIn Python, there is the easiest way to compute factorial. The built-in-function math provide a direct factorial number.\n\nimport math\n\nprint(\"The factorial of 5 is: \", math.factorial(5))\n\nThe factorial of 5 is:  120\n\n\nTo implement the factorial, there are several way.\n\n\nDue to its definition, the naivest way to compute it is using for loop. Set the first value as 1, and multiply number 1 to N.\n\n\n\n\n\n\nTime Complexity\n\n\n\nWith for loop, the factorial will be computed after \\(N\\) times of multiplications. Therefore its time complexity is \\(O(N)\\).\n\n\n\ndef factorial(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\nsource code of math.factorial\n\n\n\n\n\nstatic PyObject *\nmath_factorial(PyObject *module, PyObject *arg)\n/*[clinic end generated code: output=6686f26fae00e9ca input=713fb771677e8c31]*/\n{\n    long x, two_valuation;\n    int overflow;\n    PyObject *result, *odd_part;\n\n    x = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (x == -1 && PyErr_Occurred()) {\n        return NULL;\n    }\n    else if (overflow == 1) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"factorial() argument should not exceed %ld\",\n                     LONG_MAX);\n        return NULL;\n    }\n    else if (overflow == -1 || x &lt; 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"factorial() not defined for negative values\");\n        return NULL;\n    }\n\n    /* use lookup table if x is small */\n    if (x &lt; (long)Py_ARRAY_LENGTH(SmallFactorials))\n        return PyLong_FromUnsignedLong(SmallFactorials[x]);\n\n    /* else express in the form odd_part * 2**two_valuation, and compute as\n       odd_part &lt;&lt; two_valuation. */\n    odd_part = factorial_odd_part(x);\n    if (odd_part == NULL)\n        return NULL;\n    two_valuation = x - count_set_bits(x);\n    result = _PyLong_Lshift(odd_part, two_valuation);\n    Py_DECREF(odd_part);\n    return result;\n}\n\n\n\n\n\n\n\nIf loop can be a solution, recursive can be the solution either. Recursive function is a function that calls itself, like a fractal. By calling itself, the function can be computed by smaller value of the function. Therefore, ‘base case’ is required, which is the smallest value of the function. In case of factorial, factorial should be positive value. Therefore the smallest value of factorial is 1, so does base case. If the function reaches 1, the function will return 1, and the function will be computed by the previous value of the function.\nFactorial can be rewritten by smaller factorial, such as:\n\\[5! = 5 * 4 * (4 -1) * ((4 -1) -1) * (((4 -1) -1) -1) = 5 * 4!\\]\nIn this case, \\(5!\\) can be replaced with \\(5 * 4!\\). Similarly, \\(4!\\) can be replaced with \\(4 * 3!\\), and so on until the base case, 1. Therefore, \\(5!\\) is the same as \\(5 * 4 * 3* 2 * 1!\\).\nTo implement recursive function, define the function that calls itself with the smaller value of the function. like below:\n\ndef factorial(n):\n# ...\n    return n * factorial(n - 1)\n\nThe function will return \\(n * (n - 1)!\\), and \\((n - 1)!\\) will return \\(n - 1 * (n - 2)!\\), and so on. Yet if there is no base case, the function will be computed infinitely. Therefore, the base case have to be defined to stop the function.\nThis can be implemented by recursive function.\n\ndef factorial(n):\n    if n == 1:      # the last value of the function\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nfactorial(5)\n\n120\n\n\nThe equation above follows the direction below:\n\n# put n as an input of the function\nn = 5\nfactorial_5 = factorial(5)\n\n# since n is not 1, the factorial function will return n * (n - 1)!\nfactorial_5 = 5 * factorial(4)\n\n# put n as 4, and repeat the function\nfactorial_4 = 5 * 4 * factorial(3)\nfactorial_3 = 5 * 4 * 3 * factorial(2)\nfactorial_2 = 5 * 4 * 3 * 2 * factorial(1)\n\n# since n is 1, the function will return 1\nfactorial_1 = factorial(1)\n            = 1\n\n# compute the whole function\nfactorial_5 = 5 * factorial_4\n            = 5 * 4 * factorial_3\n            = 5 * 4 * 3 * factorial_2\n            = 5 * 4 * 3 * 2 * factorial_1\n            = 5 * 4 * 3 * 2 * 1\n            = 120\n\n\n\n\n\n\n\nRecursive Function in One Line\n\n\n\n\n\nFurthermore, this recursive function can be written in one line.\n\nfactorial = lambda n: n * factorial(n - 1) if n &gt; 1 else 1\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe factorial function computes 1 time of multiplication for each call of the function. To compute the whole factorial, the function will be called \\(N\\) times. Therefore, the time complexity of the recursive function is \\(O(N)\\).\n\n\n\n\n\n\n\nreduce reduces ‘iterable’ to a single value by applying the function passed as an argument.\n\n\nfrom functools import reduce\n\n# reduce(function, iterable[, initial]) -&gt; value\nreduce(lambda x, y: x * y, range(1, 6), 1)\n\n120\n\n\nPython provides a built-in function reduce in functools module. It is a function that applies a function of the two arguments cumulatively to the items of an iterable.\nIn case of the example above, the lambda function lambda x, y: x * y takes two arguments x, y and multiply them. The function reduce applies the lambda function to the range of 1 to 6. Since the initial value is 1, this lambda function will multiply 1 to 1, 2, 3, 4, 5 and return 120.\n\n# x will take 1 and computed result of the lambda function\n# y will take value from 1 to 5, which came from the range\n\n\"\"\"\nx = 1, y = 1 -&gt; 1\nx = 1, y = 2 -&gt; 2\nx = 2, y = 3 -&gt; 6\nx = 6, y = 4 -&gt; 24\nx = 24, y = 5 -&gt; 120\n\"\"\"\n\nprint(reduce(lambda x, y: x * y, range(1, 2), 1))\nprint(reduce(lambda x, y: x * y, range(1, 3), 1))\nprint(reduce(lambda x, y: x * y, range(1, 4), 1))\nprint(reduce(lambda x, y: x * y, range(1, 5), 1))\nprint(reduce(lambda x, y: x * y, range(1, 6), 1))\n\n1\n2\n6\n24\n120\n\n\n\n\n\n\n\n\nFold and Reduce\n\n\n\n\n\n\n\n\nreduce\n\n\nreduce also termed as ‘fold’ or ‘accumulate’, ‘compress’ in functional programming. Fold recursively breaks that structure down, replacing it with the results of applying a combining function at each node on its terminal values and the recursive results. (wikipedia\n\nPython’s reduce(): From Functional to Pythonic Style | Real Python\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe reduce function applies the function to the iterable. Therefore, if the time complexity of the function is \\(O(N)\\) and the number of elements in the iterable is \\(N\\), the time complexity of the reduce function is \\(O(N)\\).\n\n\n\n\n\n\n\n# math.factorial\nimport math\n\n%timeit math.factorial(5)\n\n17.2 ns ± 0.101 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)\n\n\n\n# for loop\ndef fac_for(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\n%timeit fac_for(5)\n\n155 ns ± 14.2 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# recursive\ndef fac_recursive(n):\n    return n * fac_recursive(n - 1) if n &gt; 1 else 1\n\n%timeit fac_recursive(5)\n\n176 ns ± 4.13 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# reduce\nfrom functools import reduce\ndef fac_reduce(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1), 1)\n\n%timeit fac_reduce(5)\n\n315 ns ± 6.19 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)"
  },
  {
    "objectID": "algorithm/factorial.html#factorial-in-python",
    "href": "algorithm/factorial.html#factorial-in-python",
    "title": "Factorial in Python",
    "section": "",
    "text": "Factorial is the product of all positive integers less than or equal to.. For example, factorial of 5 is calculated by the equation below:\n\\[5! = 5 * 4 * 3 * 2 * 1 = 120\\]\nIn Python, there is the easiest way to compute factorial. The built-in-function math provide a direct factorial number.\n\nimport math\n\nprint(\"The factorial of 5 is: \", math.factorial(5))\n\nThe factorial of 5 is:  120\n\n\nTo implement the factorial, there are several way.\n\n\nDue to its definition, the naivest way to compute it is using for loop. Set the first value as 1, and multiply number 1 to N.\n\n\n\n\n\n\nTime Complexity\n\n\n\nWith for loop, the factorial will be computed after \\(N\\) times of multiplications. Therefore its time complexity is \\(O(N)\\).\n\n\n\ndef factorial(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\nsource code of math.factorial\n\n\n\n\n\nstatic PyObject *\nmath_factorial(PyObject *module, PyObject *arg)\n/*[clinic end generated code: output=6686f26fae00e9ca input=713fb771677e8c31]*/\n{\n    long x, two_valuation;\n    int overflow;\n    PyObject *result, *odd_part;\n\n    x = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (x == -1 && PyErr_Occurred()) {\n        return NULL;\n    }\n    else if (overflow == 1) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"factorial() argument should not exceed %ld\",\n                     LONG_MAX);\n        return NULL;\n    }\n    else if (overflow == -1 || x &lt; 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"factorial() not defined for negative values\");\n        return NULL;\n    }\n\n    /* use lookup table if x is small */\n    if (x &lt; (long)Py_ARRAY_LENGTH(SmallFactorials))\n        return PyLong_FromUnsignedLong(SmallFactorials[x]);\n\n    /* else express in the form odd_part * 2**two_valuation, and compute as\n       odd_part &lt;&lt; two_valuation. */\n    odd_part = factorial_odd_part(x);\n    if (odd_part == NULL)\n        return NULL;\n    two_valuation = x - count_set_bits(x);\n    result = _PyLong_Lshift(odd_part, two_valuation);\n    Py_DECREF(odd_part);\n    return result;\n}\n\n\n\n\n\n\n\nIf loop can be a solution, recursive can be the solution either. Recursive function is a function that calls itself, like a fractal. By calling itself, the function can be computed by smaller value of the function. Therefore, ‘base case’ is required, which is the smallest value of the function. In case of factorial, factorial should be positive value. Therefore the smallest value of factorial is 1, so does base case. If the function reaches 1, the function will return 1, and the function will be computed by the previous value of the function.\nFactorial can be rewritten by smaller factorial, such as:\n\\[5! = 5 * 4 * (4 -1) * ((4 -1) -1) * (((4 -1) -1) -1) = 5 * 4!\\]\nIn this case, \\(5!\\) can be replaced with \\(5 * 4!\\). Similarly, \\(4!\\) can be replaced with \\(4 * 3!\\), and so on until the base case, 1. Therefore, \\(5!\\) is the same as \\(5 * 4 * 3* 2 * 1!\\).\nTo implement recursive function, define the function that calls itself with the smaller value of the function. like below:\n\ndef factorial(n):\n# ...\n    return n * factorial(n - 1)\n\nThe function will return \\(n * (n - 1)!\\), and \\((n - 1)!\\) will return \\(n - 1 * (n - 2)!\\), and so on. Yet if there is no base case, the function will be computed infinitely. Therefore, the base case have to be defined to stop the function.\nThis can be implemented by recursive function.\n\ndef factorial(n):\n    if n == 1:      # the last value of the function\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nfactorial(5)\n\n120\n\n\nThe equation above follows the direction below:\n\n# put n as an input of the function\nn = 5\nfactorial_5 = factorial(5)\n\n# since n is not 1, the factorial function will return n * (n - 1)!\nfactorial_5 = 5 * factorial(4)\n\n# put n as 4, and repeat the function\nfactorial_4 = 5 * 4 * factorial(3)\nfactorial_3 = 5 * 4 * 3 * factorial(2)\nfactorial_2 = 5 * 4 * 3 * 2 * factorial(1)\n\n# since n is 1, the function will return 1\nfactorial_1 = factorial(1)\n            = 1\n\n# compute the whole function\nfactorial_5 = 5 * factorial_4\n            = 5 * 4 * factorial_3\n            = 5 * 4 * 3 * factorial_2\n            = 5 * 4 * 3 * 2 * factorial_1\n            = 5 * 4 * 3 * 2 * 1\n            = 120\n\n\n\n\n\n\n\nRecursive Function in One Line\n\n\n\n\n\nFurthermore, this recursive function can be written in one line.\n\nfactorial = lambda n: n * factorial(n - 1) if n &gt; 1 else 1\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe factorial function computes 1 time of multiplication for each call of the function. To compute the whole factorial, the function will be called \\(N\\) times. Therefore, the time complexity of the recursive function is \\(O(N)\\).\n\n\n\n\n\n\n\nreduce reduces ‘iterable’ to a single value by applying the function passed as an argument.\n\n\nfrom functools import reduce\n\n# reduce(function, iterable[, initial]) -&gt; value\nreduce(lambda x, y: x * y, range(1, 6), 1)\n\n120\n\n\nPython provides a built-in function reduce in functools module. It is a function that applies a function of the two arguments cumulatively to the items of an iterable.\nIn case of the example above, the lambda function lambda x, y: x * y takes two arguments x, y and multiply them. The function reduce applies the lambda function to the range of 1 to 6. Since the initial value is 1, this lambda function will multiply 1 to 1, 2, 3, 4, 5 and return 120.\n\n# x will take 1 and computed result of the lambda function\n# y will take value from 1 to 5, which came from the range\n\n\"\"\"\nx = 1, y = 1 -&gt; 1\nx = 1, y = 2 -&gt; 2\nx = 2, y = 3 -&gt; 6\nx = 6, y = 4 -&gt; 24\nx = 24, y = 5 -&gt; 120\n\"\"\"\n\nprint(reduce(lambda x, y: x * y, range(1, 2), 1))\nprint(reduce(lambda x, y: x * y, range(1, 3), 1))\nprint(reduce(lambda x, y: x * y, range(1, 4), 1))\nprint(reduce(lambda x, y: x * y, range(1, 5), 1))\nprint(reduce(lambda x, y: x * y, range(1, 6), 1))\n\n1\n2\n6\n24\n120\n\n\n\n\n\n\n\n\nFold and Reduce\n\n\n\n\n\n\n\n\nreduce\n\n\nreduce also termed as ‘fold’ or ‘accumulate’, ‘compress’ in functional programming. Fold recursively breaks that structure down, replacing it with the results of applying a combining function at each node on its terminal values and the recursive results. (wikipedia\n\nPython’s reduce(): From Functional to Pythonic Style | Real Python\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe reduce function applies the function to the iterable. Therefore, if the time complexity of the function is \\(O(N)\\) and the number of elements in the iterable is \\(N\\), the time complexity of the reduce function is \\(O(N)\\).\n\n\n\n\n\n\n\n# math.factorial\nimport math\n\n%timeit math.factorial(5)\n\n17.2 ns ± 0.101 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)\n\n\n\n# for loop\ndef fac_for(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\n%timeit fac_for(5)\n\n155 ns ± 14.2 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# recursive\ndef fac_recursive(n):\n    return n * fac_recursive(n - 1) if n &gt; 1 else 1\n\n%timeit fac_recursive(5)\n\n176 ns ± 4.13 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# reduce\nfrom functools import reduce\ndef fac_reduce(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1), 1)\n\n%timeit fac_reduce(5)\n\n315 ns ± 6.19 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "YeEun Hong",
    "section": "",
    "text": "AI product engineer with 4 years of expreience, It’s my interest to create tools that enhance productivity and creativity. Computer Vision, such as object detection and image segmentation is what I’ve focused since, however applying LLM to personalizing user experience. is my recent interest too.\n\n\nSuch a person who boldly asks ‘why’ and ‘why not’ was and will be me. The approach has been my guiding principle up to this day. I’m fascinated by how technology can breathe new life into everyday experiences. Throughout my journey, I’ve gained diverse perspectives and insights from various fields. Not the destination but the journey itself is my main concern. I will continue to push my technical boundaries constantly."
  }
]