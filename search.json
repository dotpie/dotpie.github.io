[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "archive",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Categories\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Reading Time (Low to High)\n        \n         \n          Reading Time (High to Low)\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nFactorial in Python\n\n\nImplementing Factorial in Python with three different methods\n\n\n5 min\n\n\n\nalgorithms\n\n\n\n\ndotpie\n\n\nOct 2, 2024\n\n\n\n\n\n\n\n\n\n\n\nWhy Binary and Hexadecimal are Important in Python\n\n\nUnderstanding the usage and relation of Binary and Hexadecimal in Python\n\n\n11 min\n\n\n\ncomputer science\n\n\npython\n\n\n\n\ndotpie\n\n\nOct 3, 2024\n\n\n\n\n\n\n\n\n\n\n\nBeing Part of Other’s Growth\n\n\n4 min\n\n\n\nsoft-skills\n\n\nself-review\n\n\n\n\ndotpie\n\n\nSep 29, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "cs/binary.html",
    "href": "cs/binary.html",
    "title": "Why Binary and Hexadecimal are Important in Python",
    "section": "",
    "text": "Introduction\n\n\n\n\n\nKnowing that computers use binary language, yet as a Python programmer, I haven’t had much chance to work with binary and hexadecimal in usual programming tasks. Binary numbers didn’t feel close to me. Since high-level programming like Python deals with abstract data types. Binary were looked rather theoretical.\nHowever, when I came across a problem required to handle exponential values of 2, I found out practical side of binary and hexadecimal. This article provides a brief review of binary and hexadecimal representation in Python, along with their role in computer architecture and real-world applications.\nDespite the fact that binary and hexadecimal systems are fundamental to computer science, many programmers don’t often directly handle these number systems in their day-to-day task. Nevertheless, understanding and utilizing these number system is crucial in various aspects of programming and computer science.\nIt’s important to note that binary can be used to represent anything in computing, from text and images to video and beyond. As we delve into this topic, we’ll explore how these number systems play a vital role in both low-level and high-level programming."
  },
  {
    "objectID": "cs/binary.html#binary-representation-with-open-function",
    "href": "cs/binary.html#binary-representation-with-open-function",
    "title": "Why Binary and Hexadecimal are Important in Python",
    "section": "Binary Representation with open() Function",
    "text": "Binary Representation with open() Function\nMy favicon image is 16x16 pixels and it is a PNG file like below. Let’s read the file in binary mode and see the first 5 bytes of it.\n\n# Read the favicon image in binary mode\nimport os\n\ndef read_file(file_path):\n    with open(file_path, 'rb') as file:     # Open the file in binary mode\n        return file.read()\n\nfile_path = os.getcwd() + '/favicon-16x16.png'\ndata = read_file(file_path)\n\nThe variable data could be shown both in an image and in binary format.\nFirst, you can see the favicon image below. The normal format of the image.\n\n# Display the favicon image\nfrom PIL import Image\nfrom IPython.display import display\n\nfavicon_img = Image.open(file_path)\ndisplay(favicon_img)\n\n\n\n\n\n\n\n\nWhereas, the binary format of the image is as follows:\n\n# Display the first 5 bytes of the file in binary\nfor b in (data[:5]):\n    print(bin(b), end=\" \")\n\n0b10001001 0b1010000 0b1001110 0b1000111 0b1101 \n\n\n\n\n\n\n\n\nFile Object in Python: Text, Buffered Binary, Raw Binary\n\n\n\n\n\nPython has three type of main file objects: text file, buffered binary file and raw binary file. open() function is the canonical way to create a file object. It takes two arguments: file path and mode.\nFiles can be opened in two modes: text mode and binary mode. Text mode is for text data, binary mode is for non-text data like images, audio, etc. Binary mode does not perform any encoding or decoding. It reads and writes data as it is.\nTo open a file in binary mode, you need to add b to the mode string. For example, rb for reading and wb for writing. With this binary mode, you can get the bytes object instead of str object. A bytes object is a sequence of integers in the range of 0 to 255. This is why the output of the code below is range of 0 to 255, not 0 or 1.\n\n# Open a file in binary mode\nfor b in (data[:5]):\n    print((b), end=\" \")\n\n137 80 78 71 13 \n\n\nFor more information, you can check the official Python documentation:\n\nhttps://docs.python.org/3/library/functions.html#open\nhttps://docs.python.org/3/glossary.html#term-file-object\nhttps://docs.python.org/3/library/stdtypes.html#bytes"
  },
  {
    "objectID": "cs/binary.html#basis-unit-of-information-bit-and-byte",
    "href": "cs/binary.html#basis-unit-of-information-bit-and-byte",
    "title": "Why Binary and Hexadecimal are Important in Python",
    "section": "Basis unit of information: Bit and Byte",
    "text": "Basis unit of information: Bit and Byte\nAs you can see, my favicon image is represented in binary format. The first 5 bytes of the image are as follows:\n0b10001001 0b1010000 0b1001110 0b1000111 0b1101\nIn case of ‘0b10001001’, ‘0b’ is a prefix to indicate that the number is in binary format. The number itself is 10001001. Each digit in binary number is called a bit, which is the smallest unit of signal in a computer science. Bit is a short form of binary digit.\nBit only can have two values, 0 or 1 (off or on). \\(N\\) bits can represent \\(2^{N}\\) values. It is too small to indicate any meaningful data. Therefore, it is grouped into a larger unit called byte, which is the basic unit of data.\nIn the above example, 10001001 is consisted of 8 bits. As you can see, 1 byte can represent \\(2^{8}\\) or 256 values. Does byte enough to describe information? Yes, it is. For example, 1 byte is enough to indicate a character in ASCII code. This is why the byte is the basic unit of data in computer science. Since the basic unit of data is byte, every unit of data is ends with ‘byte’. For example, kilobyte, megabyte, gigabyte, terabyte, etc. are all ends with ‘byte’."
  },
  {
    "objectID": "cs/binary.html#hexadecimal-compact-representation-of-binary-data",
    "href": "cs/binary.html#hexadecimal-compact-representation-of-binary-data",
    "title": "Why Binary and Hexadecimal are Important in Python",
    "section": "Hexadecimal: Compact Representation of Binary Data",
    "text": "Hexadecimal: Compact Representation of Binary Data\nWhat about hexadecimal? Hexadecimal is a numeric system that based on 16. It uses 16 symbols: 0-9 and A-F, the most compact way to compress binary data. For example, only 2 digits are enough to indicate number 255 in hexadecimal, whereas 8 digits are needed in binary, like 0b11111111. Namely, 1 byte can be represented by 2 hexadecimal digits.\nStill computer uses binary number, hexadecimal is compromise between programmer and computer. It is easier to read and write than binary, also easily convert to binary. This is why hexadecimal is widely used in computer science, especially in low-level programming: expressing memory addresses, register values, and other byte based data, for instance."
  },
  {
    "objectID": "cs/binary.html#convert-between-number-systems",
    "href": "cs/binary.html#convert-between-number-systems",
    "title": "Why Binary and Hexadecimal are Important in Python",
    "section": "Convert between number systems",
    "text": "Convert between number systems\n\nConvert different base numbers to decimal\nPython provides built-in functions to convert different base numbers to decimal.\nBinary numbers are string of 0s and 1s. To convert binary to decimal, int function can be used with base 2. Normally, int function takes one argument, which is a string of number. However, int function can takes two arguments: number and base. For example, int('1010', 2) converts binary number ‘1010’ to decimal number 10.\n\n# Convert binary to decimal\n# class int( x: str | bytes | bytearray, /, base: SupportsIndex) -&gt; int\n\nbinary_num = '1010'\ndecimal_num = int(binary_num, 2)\n\nprint(f\"Binary number {binary_num} is converted to decimal number {decimal_num}\")\n\nBinary number 1010 is converted to decimal number 10\n\n\nLikewise, hexadecimal number can be converted to decimal number. Since hex numbers are described of 0-9 and A-F, its data type is string. To convert hexadecimal to decimal, int function can be used with base 16. For example, int('FF', 16) converts hexadecimal number ‘FF’ to decimal number 255.\n\n# Convert hexadecimal to decimal\nhex_num = 'FF'\ndecimal_num = int(hex_num, 16)\n\nprint(f\"Hexadecimal number {hex_num} is converted to decimal number {decimal_num}\")\n\nHexadecimal number FF is converted to decimal number 255\n\n\n\n\n\nConvert decimal to different base numbers\nTo convert decimal number to binary or hexadecimal, bin and hex functions can be used. bin function converts decimal number to binary number. hex function converts decimal number to hexadecimal number.\n\n# Convert decimal to binary\n# (function) def bin(number: int | SupportsIndex, / ) -&gt; str\n\ndecimal_num = 10\nbinary_num = bin(decimal_num)\n\nprint(f\"Decimal number {decimal_num} is converted to binary number {binary_num}\")\n\nDecimal number 10 is converted to binary number 0b1010\n\n\n\n# Convert decimal to hexadecimal\n# (function) def hex(number: int | SupportsIndex, / ) -&gt; str\n\ndecimal_num = 255\nhex_num = hex(decimal_num)\n\nprint(f\"Decimal number {decimal_num} is converted to hexadecimal number {hex_num}\")\n\nDecimal number 255 is converted to hexadecimal number 0xff"
  },
  {
    "objectID": "cs/binary.html#bitwise-operations",
    "href": "cs/binary.html#bitwise-operations",
    "title": "Why Binary and Hexadecimal are Important in Python",
    "section": "Bitwise Operations",
    "text": "Bitwise Operations\nBitwise operations are performed on binary numbers. These operators are particularly useful when dealing with binary representations directly. In certain situations, it significantly improves the performance of the code as well.\nThe main bitwise operators in Python are:\n\n& (AND): Returns 1 if both bits are 1.\n| (OR): Returns 1 if either of the bits is 1.\n^ (XOR): Returns 1 if the bits are different.\n~ (NOT): Inverts the bits.\n&lt;&lt; (Left Shift): Shifts the bits to the left.\n&gt;&gt; (Right Shift): Shifts the bits to the right.\n\n\n\nDifference between bitwise and logical operators\nIn Python, there are bitwise operators (&, |, ~) and their logical counterparts (and, or, not). While the basic concepts are similar, their implementations differ. Both & and and return True when both conditions are True, but & operates on individual bits. Similarly, | and or, as well as ~ and not, have analogous functions but work at different levels of abstraction. These operators may seem interchangeable, in some situations, yet understanding their differences is crucial.\n\n# Bitwise AND operator\nprint(f\"Bitwise AND: {5 & 8}\")\nprint(f\"Logical AND: {5 and 8}\")\n\nBitwise AND: 0\nLogical AND: 8\n\n\nWhy does the output differ? The & operator works on individual bits, whereas the and operator evaluates compare the entire expression of operands: 5, 8.\n\n# Binary representation of 5 and 8\nprint(f\"Binary of 5: {bin(5)}\")\nprint(f\"Binary of 8: {bin(8)}\")\n\nBinary of 5: 0b101\nBinary of 8: 0b1000\n\n\nThe binary representation of 5 and 8 are 0b101 and 0b1000, respectively. The bitwise AND operation is performed on each bit of the two numbers. There are no common digits/numbers/bits between 5 and 8. Therefore the result is 0b0, which is 0 in decimal.\nWhat about the logical AND operation? The and operator evaluates the truth of the entire expression. In this case, both 5 and 8 are considered True in Python. The and operator returns the second operand, which is 8 in this case. Therefore, the output is 8.\n\n\n\n\n\n\nKey Differences between Bitwise and Logical Operators\n\n\n\n\n\nHere are some key differences between bitwise and logical operators:\n\n\n\n\n\n\n\n\n\nBitwise Operator\nLogical Operator\n\n\n\n\nUsage\nBinary operation\nLogical operation\n\n\nTarget\ninteger value\nBoolean in most case\n\n\nReturn Value\nBitwise result (integer)\nOne of the operands\n\n\nPrecedence\nHigh\nLow\n\n\nEvaluation\nAll operands\nDoes not evaluate second operand if first operand is False\n\n\nBoolean\nTreats True as 1, False as 0\nUses boolean class as is\n\n\nin Expression\nPerform AND operation bit by bit\nEvaluates logical truth of entire expression\n\n\n\n\n\n\n\n\n\nBitwise Operations in Python\nBitwise Operations can be easily understood by the following images:\n\n\n\n\n\n\n\nAND\nOR\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nXOR\nNOT\n\n\n\n\n\n\n\n\n\n\nGIF: RealPython.com - Bitwise Operators in Python\n\n\n\nShift Operators\nOperators above are compare the bits of two numbers. However, &lt;&lt; and &gt;&gt; operators works tricky. &lt;&lt; and &gt;&gt; operators called left shift and right shift operators. They shift the bits of a number to the left or right.\nIn terms of shift operators, it is important to note what shifting means in binary numbers. Shifting to the left means multiplying the number by 2, likewise shifting to the right means dividing the number by 2. Remind that every digit in binary number is power of 2.\nLeft shift operator shifts the bits to the left, and fills the empty bits with 0. Let’s see how it works in Python.\n\n# Bitwise Left Shift\nnumber = 5\nprint(f\"The binary of {number} is {bin(number)}\")\n\nThe binary of 5 is 0b101\n\n\nDecimal number 5 is represented in binary as 101(2). When shifted to the left by 1, the result is 1010(1), which is same as \\(5 * 2^{1}\\).\n\nshifted = number &lt;&lt; 1\nprint(f\"Left Shifted by 1: {shifted} ({bin(shifted)})\")\nprint(f\"Left shifted by 1 is equal to {number} * 2 = {number * 2}\")\n\nLeft Shifted by 1: 10 (0b1010)\nLeft shifted by 1 is equal to 5 * 2 = 10\n\n\nLikewise, when shifted to the left by 2, the result is 10100(4), which is same as \\(5 * 2^{2}\\).\n\nshifted_2 = number &lt;&lt; 2\nprint(f\"Left Shifted by 2: {shifted_2} ({bin(shifted_2)})\")\nprint(f\"Left shifted by 2 is equal to {number} * 4 = {number * 4}\")\n\nLeft Shifted by 2: 20 (0b10100)\nLeft shifted by 2 is equal to 5 * 4 = 20\n\n\nHow about shifting to the left by 7? The result is 1010000000(128), which is same as \\(5 * 2^{7}\\). Only adding 7 zeros to the right is the same as multiplying by 128.\n\nshifted_7 = number &lt;&lt; 7\nprint(f\"Left Shifted by 7: {shifted_7} ({bin(shifted_7)})\")\n\nLeft Shifted by 7: 640 (0b1010000000)\n\n\nThere is right shift operator either. Right shift operator shifts the bit to the right, which is equivalent to dividing the number by 2. Let’s bring back shifted_7 to the original number.\n\nprint(f\"The Original number is {number} ({bin(number)})\")\nprint(f\"Left Shifted by 7 was {shifted_7} ({bin(shifted_7)})\")\n\nThe Original number is 5 (0b101)\nLeft Shifted by 7 was 640 (0b1010000000)\n\n\n\n# Bitwise Right Shift\nshifted_back = shifted_7 &gt;&gt; 1\nprint(f\"Right Shifted by 1: {shifted_back} ({bin(shifted_back)})\")\n\nRight Shifted by 1: 320 (0b101000000)\n\n\n\nshifted_back_2 = shifted_7 &gt;&gt; 2\nprint(f\"Right Shifted by 2: {shifted_back_2} ({bin(shifted_back_2)})\")\n\nRight Shifted by 2: 160 (0b10100000)\n\n\n\n# ...\nshifted_back_7 = shifted_7 &gt;&gt; 7\nprint(f\"Right Shifted by 7: {shifted_back_7} ({bin(shifted_back_7)})\")\n\nRight Shifted by 7: 5 (0b101)\n\n\n\n\n\n\n\n\nShifted Operators to Mathematical Operations\n\n\n\n\n\n\\[a &lt;&lt; n = a \\times 2^{n}\\] \\[a &gt;&gt; n = a \\div 2^{n}\\]\n\n\n\n\n\n\n\n\n\nWhy does the shift operator needed?\n\n\n\n\n\nBitwise shift operators are useful in optimization. Computers can not multiply or divide numbers directly. They can only add and subtract. Therefore, multiplying or dividing large numbers takes a large amout of computation. However, shifting bits is much faster than multiplying or dividing. This is why shift operators are used in low-level programming.\nThis is theoretical explanation, but in real-world, compilers and interpreters are smart enough to optimize the code. Python is a high-level language, which means readability is more important than slight performance improvement. Therefore, using shift operators as a means of premature optimization is not recommended.\n\nhttps://realpython.com/python-bitwise-operators/\n\n\n\n\n\n\n\n\n\n\nRight Shift Operator: What if the number is negative?\n\n\n\n\n\nNormally, dividing operation works same in positive and negative numbers. However, right shift operator works differently in negative numbers because of the way negative numbers are represented in binary.\nComputer uses two’s complement1 to represent negative numbers. In two’s complement, the most significant bit (MSB) is used as a sign bit. If the sign bit is 1, the number is negative. When right shifting a negative number, the sign bit is copied to the empty bits. This is called sign extension2.\n\n# Right Shift Operator with negative number\ndef show_bits(num, bits=8):\n    \"\"\"\n    Show the integer number in binary format\n    \"\"\"\n    if num &lt; 0:\n        # Represent negative number as a two's complement\n        num = (1 &lt;&lt; bits) + num\n    return format(num, f'0{bits}b')\n\nThe function above is implementation of showing the binary bits of a number. If the number is negative, it convert the number to two’s complement. First, extend the bits to determined length of bits, which is 8 in this case. Then, add the number to \\(2^{bits=8}\\). As added number is negative, it is same as subtracting the number from \\(2^{bits=8}\\). This is how two’s complement works, that is flipping the bit values.\nNow, every number will be shown in positive number with 8 bits. In this callout, there are 2 examples of right shift operator with negative numbers.\n\nThe result of right shift is rounded down to the negative direction.\n\n\n# Right shift of negative number\nprint(f\"Right Shift of -5: {show_bits(-5)} &gt;&gt; 1 = {show_bits(-5 &gt;&gt; 1)}\")\nprint(f\"Right Shift of -6: {show_bits(-6)} &gt;&gt; 1 = {show_bits(-6 &gt;&gt; 1)}\")\n\nRight Shift of -5: 11111011 &gt;&gt; 1 = 11111101\nRight Shift of -6: 11111010 &gt;&gt; 1 = 11111101\n\n\nThe right shift of -5 and -6 by 1 is both -3. In fact, -5 divided by 2 should be -2.5. However, computers can only represent integers. This is why -5 &gt;&gt; 1 is -3.\n\nThe sign bit is copied to the empty bits.\n\n\n# Right shift of -1\nprint(f\"Right Shift of -1: {show_bits(-1)} &gt;&gt; 1 = {show_bits(-1 &gt;&gt; 1)}\")\n\nRight Shift of -1: 11111111 &gt;&gt; 1 = 11111111\n\n\nAfter shifting the negative number to the right, left side is filled with 1. This is because the sign bit is copied to the empty bits. Likewise, the right shift of -1 remains -1 because every bit is filled with 1.\n\n\n\n\n\n\n\n\n\nTwo’s Complement - Wikipedia↩︎\nSign Extension - Wikipedia↩︎"
  },
  {
    "objectID": "algorithm/factorial.html",
    "href": "algorithm/factorial.html",
    "title": "Factorial in Python",
    "section": "",
    "text": "Factorial is the product of all positive integers less than or equal to.. For example, factorial of 5 is calculated by the equation below:\n\\[5! = 5 * 4 * 3 * 2 * 1 = 120\\]\nIn Python, there is the easiest way to compute factorial. The built-in-function math provide a direct factorial number.\n\nimport math\n\nprint(\"The factorial of 5 is: \", math.factorial(5))\n\nThe factorial of 5 is:  120\n\n\nTo implement the factorial, there are several way.\n\n\nDue to its definition, the naivest way to compute it is using for loop. Set the first value as 1, and multiply number 1 to N.\n\n\n\n\n\n\nTime Complexity\n\n\n\nWith for loop, the factorial will be computed after \\(N\\) times of multiplications. Therefore its time complexity is \\(O(N)\\).\n\n\n\ndef factorial(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\nsource code of math.factorial\n\n\n\n\n\nstatic PyObject *\nmath_factorial(PyObject *module, PyObject *arg)\n/*[clinic end generated code: output=6686f26fae00e9ca input=713fb771677e8c31]*/\n{\n    long x, two_valuation;\n    int overflow;\n    PyObject *result, *odd_part;\n\n    x = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (x == -1 && PyErr_Occurred()) {\n        return NULL;\n    }\n    else if (overflow == 1) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"factorial() argument should not exceed %ld\",\n                     LONG_MAX);\n        return NULL;\n    }\n    else if (overflow == -1 || x &lt; 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"factorial() not defined for negative values\");\n        return NULL;\n    }\n\n    /* use lookup table if x is small */\n    if (x &lt; (long)Py_ARRAY_LENGTH(SmallFactorials))\n        return PyLong_FromUnsignedLong(SmallFactorials[x]);\n\n    /* else express in the form odd_part * 2**two_valuation, and compute as\n       odd_part &lt;&lt; two_valuation. */\n    odd_part = factorial_odd_part(x);\n    if (odd_part == NULL)\n        return NULL;\n    two_valuation = x - count_set_bits(x);\n    result = _PyLong_Lshift(odd_part, two_valuation);\n    Py_DECREF(odd_part);\n    return result;\n}\n\n\n\n\n\n\n\nIf loop can be a solution, recursive can be the solution either. Recursive function is a function that calls itself, like a fractal. By calling itself, the function can be computed by smaller value of the function. Therefore, ‘base case’ is required, which is the smallest value of the function. In case of factorial, factorial should be positive value. Therefore the smallest value of factorial is 1, so does base case. If the function reaches 1, the function will return 1, and the function will be computed by the previous value of the function.\nFactorial can be rewritten by smaller factorial, such as:\n\\[5! = 5 * 4 * (4 -1) * ((4 -1) -1) * (((4 -1) -1) -1) = 5 * 4!\\]\nIn this case, \\(5!\\) can be replaced with \\(5 * 4!\\). Similarly, \\(4!\\) can be replaced with \\(4 * 3!\\), and so on until the base case, 1. Therefore, \\(5!\\) is the same as \\(5 * 4 * 3* 2 * 1!\\).\nTo implement recursive function, define the function that calls itself with the smaller value of the function. like below:\n\ndef factorial(n):\n# ...\n    return n * factorial(n - 1)\n\nThe function will return \\(n * (n - 1)!\\), and \\((n - 1)!\\) will return \\(n - 1 * (n - 2)!\\), and so on. Yet if there is no base case, the function will be computed infinitely. Therefore, the base case have to be defined to stop the function.\nThis can be implemented by recursive function.\n\ndef factorial(n):\n    if n == 1:      # the last value of the function\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nfactorial(5)\n\n120\n\n\nThe equation above follows the direction below:\n\n# put n as an input of the function\nn = 5\nfactorial_5 = factorial(5)\n\n# since n is not 1, the factorial function will return n * (n - 1)!\nfactorial_5 = 5 * factorial(4)\n\n# put n as 4, and repeat the function\nfactorial_4 = 5 * 4 * factorial(3)\nfactorial_3 = 5 * 4 * 3 * factorial(2)\nfactorial_2 = 5 * 4 * 3 * 2 * factorial(1)\n\n# since n is 1, the function will return 1\nfactorial_1 = factorial(1)\n            = 1\n\n# compute the whole function\nfactorial_5 = 5 * factorial_4\n            = 5 * 4 * factorial_3\n            = 5 * 4 * 3 * factorial_2\n            = 5 * 4 * 3 * 2 * factorial_1\n            = 5 * 4 * 3 * 2 * 1\n            = 120\n\n\n\n\n\n\n\nRecursive Function in One Line\n\n\n\n\n\nFurthermore, this recursive function can be written in one line.\n\nfactorial = lambda n: n * factorial(n - 1) if n &gt; 1 else 1\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe factorial function computes 1 time of multiplication for each call of the function. To compute the whole factorial, the function will be called \\(N\\) times. Therefore, the time complexity of the recursive function is \\(O(N)\\).\n\n\n\n\n\n\n\nreduce reduces ‘iterable’ to a single value by applying the function passed as an argument.\n\n\nfrom functools import reduce\n\n# reduce(function, iterable[, initial]) -&gt; value\nreduce(lambda x, y: x * y, range(1, 6), 1)\n\n120\n\n\nPython provides a built-in function reduce in functools module. It is a function that applies a function of the two arguments cumulatively to the items of an iterable.\nIn case of the example above, the lambda function lambda x, y: x * y takes two arguments x, y and multiply them. The function reduce applies the lambda function to the range of 1 to 6. Since the initial value is 1, this lambda function will multiply 1 to 1, 2, 3, 4, 5 and return 120.\n\n# x will take 1 and computed result of the lambda function\n# y will take value from 1 to 5, which came from the range\n\n\"\"\"\nx = 1, y = 1 -&gt; 1\nx = 1, y = 2 -&gt; 2\nx = 2, y = 3 -&gt; 6\nx = 6, y = 4 -&gt; 24\nx = 24, y = 5 -&gt; 120\n\"\"\"\n\nprint(reduce(lambda x, y: x * y, range(1, 2), 1))\nprint(reduce(lambda x, y: x * y, range(1, 3), 1))\nprint(reduce(lambda x, y: x * y, range(1, 4), 1))\nprint(reduce(lambda x, y: x * y, range(1, 5), 1))\nprint(reduce(lambda x, y: x * y, range(1, 6), 1))\n\n1\n2\n6\n24\n120\n\n\n\n\n\n\n\n\nFold and Reduce\n\n\n\n\n\n\n\n\nreduce\n\n\nreduce also termed as ‘fold’ or ‘accumulate’, ‘compress’ in functional programming. Fold recursively breaks that structure down, replacing it with the results of applying a combining function at each node on its terminal values and the recursive results. (wikipedia\n\nPython’s reduce(): From Functional to Pythonic Style | Real Python\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe reduce function applies the function to the iterable. Therefore, if the time complexity of the function is \\(O(N)\\) and the number of elements in the iterable is \\(N\\), the time complexity of the reduce function is \\(O(N)\\).\n\n\n\n\n\n\n\n# math.factorial\nimport math\n\n%timeit math.factorial(5)\n\n17.2 ns ± 0.101 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)\n\n\n\n# for loop\ndef fac_for(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\n%timeit fac_for(5)\n\n155 ns ± 14.2 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# recursive\ndef fac_recursive(n):\n    return n * fac_recursive(n - 1) if n &gt; 1 else 1\n\n%timeit fac_recursive(5)\n\n176 ns ± 4.13 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# reduce\nfrom functools import reduce\ndef fac_reduce(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1), 1)\n\n%timeit fac_reduce(5)\n\n315 ns ± 6.19 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)"
  },
  {
    "objectID": "algorithm/factorial.html#factorial-in-python",
    "href": "algorithm/factorial.html#factorial-in-python",
    "title": "Factorial in Python",
    "section": "",
    "text": "Factorial is the product of all positive integers less than or equal to.. For example, factorial of 5 is calculated by the equation below:\n\\[5! = 5 * 4 * 3 * 2 * 1 = 120\\]\nIn Python, there is the easiest way to compute factorial. The built-in-function math provide a direct factorial number.\n\nimport math\n\nprint(\"The factorial of 5 is: \", math.factorial(5))\n\nThe factorial of 5 is:  120\n\n\nTo implement the factorial, there are several way.\n\n\nDue to its definition, the naivest way to compute it is using for loop. Set the first value as 1, and multiply number 1 to N.\n\n\n\n\n\n\nTime Complexity\n\n\n\nWith for loop, the factorial will be computed after \\(N\\) times of multiplications. Therefore its time complexity is \\(O(N)\\).\n\n\n\ndef factorial(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\nsource code of math.factorial\n\n\n\n\n\nstatic PyObject *\nmath_factorial(PyObject *module, PyObject *arg)\n/*[clinic end generated code: output=6686f26fae00e9ca input=713fb771677e8c31]*/\n{\n    long x, two_valuation;\n    int overflow;\n    PyObject *result, *odd_part;\n\n    x = PyLong_AsLongAndOverflow(arg, &overflow);\n    if (x == -1 && PyErr_Occurred()) {\n        return NULL;\n    }\n    else if (overflow == 1) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"factorial() argument should not exceed %ld\",\n                     LONG_MAX);\n        return NULL;\n    }\n    else if (overflow == -1 || x &lt; 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"factorial() not defined for negative values\");\n        return NULL;\n    }\n\n    /* use lookup table if x is small */\n    if (x &lt; (long)Py_ARRAY_LENGTH(SmallFactorials))\n        return PyLong_FromUnsignedLong(SmallFactorials[x]);\n\n    /* else express in the form odd_part * 2**two_valuation, and compute as\n       odd_part &lt;&lt; two_valuation. */\n    odd_part = factorial_odd_part(x);\n    if (odd_part == NULL)\n        return NULL;\n    two_valuation = x - count_set_bits(x);\n    result = _PyLong_Lshift(odd_part, two_valuation);\n    Py_DECREF(odd_part);\n    return result;\n}\n\n\n\n\n\n\n\nIf loop can be a solution, recursive can be the solution either. Recursive function is a function that calls itself, like a fractal. By calling itself, the function can be computed by smaller value of the function. Therefore, ‘base case’ is required, which is the smallest value of the function. In case of factorial, factorial should be positive value. Therefore the smallest value of factorial is 1, so does base case. If the function reaches 1, the function will return 1, and the function will be computed by the previous value of the function.\nFactorial can be rewritten by smaller factorial, such as:\n\\[5! = 5 * 4 * (4 -1) * ((4 -1) -1) * (((4 -1) -1) -1) = 5 * 4!\\]\nIn this case, \\(5!\\) can be replaced with \\(5 * 4!\\). Similarly, \\(4!\\) can be replaced with \\(4 * 3!\\), and so on until the base case, 1. Therefore, \\(5!\\) is the same as \\(5 * 4 * 3* 2 * 1!\\).\nTo implement recursive function, define the function that calls itself with the smaller value of the function. like below:\n\ndef factorial(n):\n# ...\n    return n * factorial(n - 1)\n\nThe function will return \\(n * (n - 1)!\\), and \\((n - 1)!\\) will return \\(n - 1 * (n - 2)!\\), and so on. Yet if there is no base case, the function will be computed infinitely. Therefore, the base case have to be defined to stop the function.\nThis can be implemented by recursive function.\n\ndef factorial(n):\n    if n == 1:      # the last value of the function\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nfactorial(5)\n\n120\n\n\nThe equation above follows the direction below:\n\n# put n as an input of the function\nn = 5\nfactorial_5 = factorial(5)\n\n# since n is not 1, the factorial function will return n * (n - 1)!\nfactorial_5 = 5 * factorial(4)\n\n# put n as 4, and repeat the function\nfactorial_4 = 5 * 4 * factorial(3)\nfactorial_3 = 5 * 4 * 3 * factorial(2)\nfactorial_2 = 5 * 4 * 3 * 2 * factorial(1)\n\n# since n is 1, the function will return 1\nfactorial_1 = factorial(1)\n            = 1\n\n# compute the whole function\nfactorial_5 = 5 * factorial_4\n            = 5 * 4 * factorial_3\n            = 5 * 4 * 3 * factorial_2\n            = 5 * 4 * 3 * 2 * factorial_1\n            = 5 * 4 * 3 * 2 * 1\n            = 120\n\n\n\n\n\n\n\nRecursive Function in One Line\n\n\n\n\n\nFurthermore, this recursive function can be written in one line.\n\nfactorial = lambda n: n * factorial(n - 1) if n &gt; 1 else 1\nfactorial(5)\n\n120\n\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe factorial function computes 1 time of multiplication for each call of the function. To compute the whole factorial, the function will be called \\(N\\) times. Therefore, the time complexity of the recursive function is \\(O(N)\\).\n\n\n\n\n\n\n\nreduce reduces ‘iterable’ to a single value by applying the function passed as an argument.\n\n\nfrom functools import reduce\n\n# reduce(function, iterable[, initial]) -&gt; value\nreduce(lambda x, y: x * y, range(1, 6), 1)\n\n120\n\n\nPython provides a built-in function reduce in functools module. It is a function that applies a function of the two arguments cumulatively to the items of an iterable.\nIn case of the example above, the lambda function lambda x, y: x * y takes two arguments x, y and multiply them. The function reduce applies the lambda function to the range of 1 to 6. Since the initial value is 1, this lambda function will multiply 1 to 1, 2, 3, 4, 5 and return 120.\n\n# x will take 1 and computed result of the lambda function\n# y will take value from 1 to 5, which came from the range\n\n\"\"\"\nx = 1, y = 1 -&gt; 1\nx = 1, y = 2 -&gt; 2\nx = 2, y = 3 -&gt; 6\nx = 6, y = 4 -&gt; 24\nx = 24, y = 5 -&gt; 120\n\"\"\"\n\nprint(reduce(lambda x, y: x * y, range(1, 2), 1))\nprint(reduce(lambda x, y: x * y, range(1, 3), 1))\nprint(reduce(lambda x, y: x * y, range(1, 4), 1))\nprint(reduce(lambda x, y: x * y, range(1, 5), 1))\nprint(reduce(lambda x, y: x * y, range(1, 6), 1))\n\n1\n2\n6\n24\n120\n\n\n\n\n\n\n\n\nFold and Reduce\n\n\n\n\n\n\n\n\nreduce\n\n\nreduce also termed as ‘fold’ or ‘accumulate’, ‘compress’ in functional programming. Fold recursively breaks that structure down, replacing it with the results of applying a combining function at each node on its terminal values and the recursive results. (wikipedia\n\nPython’s reduce(): From Functional to Pythonic Style | Real Python\n\n\n\n\n\n\n\n\n\n\nTime Complexity\n\n\n\nThe reduce function applies the function to the iterable. Therefore, if the time complexity of the function is \\(O(N)\\) and the number of elements in the iterable is \\(N\\), the time complexity of the reduce function is \\(O(N)\\).\n\n\n\n\n\n\n\n# math.factorial\nimport math\n\n%timeit math.factorial(5)\n\n17.2 ns ± 0.101 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)\n\n\n\n# for loop\ndef fac_for(n):\n    fac = 1\n    for i in range(n, 1, -1):\n        fac *= i\n    return fac\n\n%timeit fac_for(5)\n\n155 ns ± 14.2 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# recursive\ndef fac_recursive(n):\n    return n * fac_recursive(n - 1) if n &gt; 1 else 1\n\n%timeit fac_recursive(5)\n\n176 ns ± 4.13 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\n\n\n# reduce\nfrom functools import reduce\ndef fac_reduce(n):\n    return reduce(lambda x, y: x * y, range(1, n + 1), 1)\n\n%timeit fac_reduce(5)\n\n315 ns ± 6.19 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)"
  },
  {
    "objectID": "being-part-of-others-growth.html",
    "href": "being-part-of-others-growth.html",
    "title": "Being Part of Other’s Growth",
    "section": "",
    "text": "This is a personal reflection on how I can contribute to other’s growth. It is based on my personal experiences so that it could be biased."
  },
  {
    "objectID": "being-part-of-others-growth.html#a-knowledge-sharing-chain",
    "href": "being-part-of-others-growth.html#a-knowledge-sharing-chain",
    "title": "Being Part of Other’s Growth",
    "section": "A knowledge-sharing-chain",
    "text": "A knowledge-sharing-chain\nWhat is the best way to pass on knowledge and experience to others? As a tutor, mentor, or a colleague, it was a question that I often asked myself. Most of time, I was in a position to help others grow, especially in coding and development. At the time, what I could do was to share my experiences and difficulties with others, because I was also on the middle of learning step.\nSharing was enough when I was in student circle. In circle, we were all learned together, same time, same topic. The difficulties I encountered was highly repeated to others. What I tried was stacking my own difficulties and solutions, then share it when other faced the similar issue. This kind of ‘sharing chain’ was fully effective to boost our learning speed. We were a student and a teacher at the same time. Through this process, I learned to pick up the problems that other could face, and how to share the solution in a way that they could understand."
  },
  {
    "objectID": "being-part-of-others-growth.html#the-requirements-for-sharing-knowledge",
    "href": "being-part-of-others-growth.html#the-requirements-for-sharing-knowledge",
    "title": "Being Part of Other’s Growth",
    "section": "The requirements for sharing knowledge",
    "text": "The requirements for sharing knowledge\nTo make other understand the solution, tutor have to is understanding the fundamental background of the whole situation. Tutor have to decide where to focus on, then connect the key points to make a clear path.\nYet, I was a kind of person who explore the whole picture of the problem, point out the key points is kind of complicated task. There were too many things to explain and every detail looked important. To overcome this, I made a strategy by breaking down the problem into small pieces, then pick up the key points of small pieces. After done this, I could make a clear path to the solution.\nSurely there might be someone who would like to know whole picture of the problem, but most of time, too much information makes them confused. Therefore, to give a proper answer, understanding listener’s background is essential. This is not a technical stuff, but a soft skill.\nThrough my experiences, I listed the principle to share the knowledge effectively.\n\nUnderstand the listener’s background: To decide the depth of the explanation, checking the background is essential. The language of explanation should be familiar to the listener.\nFind out how much motivated the listener is: The motivation of the lister means how much they want to know the solution. Tutoring and Teaching should not be done in a one-off session, since every knowledge has its own depth. If the listenr wants to know only the solution, then just give the solution. Learning shouldn’t be a burden. Theory and background can be explained later.\nAssociate the problem with the listener’s goal: People tends to focus when the problem is related to their own’s. As mentioned above, the listener’s motivation is important. If the listener has a goal, then associate the problem with the goal. This will make the listener feels that the issue familiar to them. Make them feel that they are not learning, but solving their own problem.\n\nThese are aimed to make the learner acquire the way to solve the problem. The goal of tutoring is not to give the solution, but to make the listener understand the way to solve the problem."
  },
  {
    "objectID": "being-part-of-others-growth.html#proactive-contribution",
    "href": "being-part-of-others-growth.html#proactive-contribution",
    "title": "Being Part of Other’s Growth",
    "section": "Proactive contribution",
    "text": "Proactive contribution\nThe most important thing in sharing knowledge is to be proactive. During the tutoring process, the tutee are going to learn how to find problems and how to ask properly, such as what to ask, what looked important, and what could be suspicious. After the steps, the tutee will be able to discuss the problem with others, and find the solution by themselves. A kind of knowledge-sharing-chain will be formed.\nTutor should not be a person who gives the solution, but the person who thinks together with the tutee. To do this, tutor have to be proactive, which means tutor have their own motivation to learn and think. This is the most important thing to be a being part of other’s growth."
  },
  {
    "objectID": "being-part-of-others-growth.html#conclusion",
    "href": "being-part-of-others-growth.html#conclusion",
    "title": "Being Part of Other’s Growth",
    "section": "Conclusion",
    "text": "Conclusion\nI am still learning how to learn as tutee and tutor. It will be continued during my developer life, and I hope that I could be a developer who have solid foundation of knowledge and experience."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "YeEun Hong",
    "section": "",
    "text": "AI product engineer with 4 years of expreience, It’s my interest to create tools that enhance productivity and creativity. Computer Vision, such as object detection and image segmentation is what I’ve focused since, however applying LLM to personalizing user experience. is my recent interest too.\n\n\nSuch a person who boldly asks ‘why’ and ‘why not’ was and will be me. The approach has been my guiding principle up to this day. I’m fascinated by how technology can breathe new life into everyday experiences. Throughout my journey, I’ve gained diverse perspectives and insights from various fields. Not the destination but the journey itself is my main concern. I will continue to push my technical boundaries constantly."
  }
]